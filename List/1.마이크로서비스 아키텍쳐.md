# 스프링 부트로 개발하는 MSA 컴포넌트

# 마이크로서비스 아키텍쳐 소개

---

## 모놀리식 아키텍쳐

- 서비스 기능을 하나의 API 컴포넌트에서 처리하는 구조
- 장점
    - 하나의 WAS에서 모든 기능을 처리
        - HTML, JS/CSS, Servlet, 이미지
    - 하나의 DB를 이용 → 구조가 간단하다
    - 시스템 개발과 운영이 자유롭다.
    - 네트워크 지연이나 데이터 유실을 걱정할 필요가 없다.
        - MSA는 마이크로 서비스 사이에 네트워크를 통해 전송되기에 데이터 유실에 대한 고려를 해야한다.
            - 또한, 통신에 사용되는 네트워크 프로토콜은 가벼워야 한다.(JSON 같은 형식의 메시지)
- 단점
    - 하나의 애플리케이션에서 모든 것을 수행하다보니 서비스 기능이 많아지면, 스파게티 코드가 될 수 있다.
    - 결국 서비스가 커지면 개발 속도나 생산성이 낮아진다.

## MSA로 전환을 고려해 볼 기준

1. 클라이언트 요청이 점점 많아지는데 로드 밸런서로 확장해도 한계가 있을때
2. 데이터베이스 성능을 높여도 더 이상 개선의 여지가 없을 때
3. 기능 확장 요구가 많짐나 현재 시스템 구조로 불가능할 때
4. 소스 코드가 너무 복잡해서 리팩터링이 필요할때
5. 기능 중 하나라도 변경되면 전체 QA를 해야할 때
6. 기능을 수정하면 다른 기능에 연쇄적으로 버그가 발생할 때
7. 개발자는 늘었는데, 개발 속도는 이전같지 않을 때

## 분산 처리 시스템

- 서비스 기능을 분리하여 두 개 이상의 API 컴포넌트에서 처리하는 구조
    - 마이크로 서비스 아키텍쳐는 분산 시스템 아키텍쳐 중 하나이다.
    - 구현이 어렵고, 여러 시스템이 유기적으로 얽혀 있어 운영이 쉽지 않다.

## 마이크로서비스 아키텍쳐

- 마이크로 서비스라는 작은 단위의 컴포넌트로 구성
    - 장점
        - 각각의 컴포넌트는 독립된 시스템 형태로 개발하고 운영
            - 느슨한 결합 → 독립된 데이터 저장소가 필요하다.
            - 서비스 변화에 자유롭다, 독립성과 민첩성을 확보
        - 대용량 데이터를 저장하고 처리하는데 자유롭다
        - 시스템 장애에 견고하다
            - 느슨하게 결합되어 있기에 서로 간에 미치는 영향이 적다.
        - 서비스 배포 주기가 빠르다
            - 모놀리식 아키텍쳐는 모든 기능이 하나의 코드베이스에서 개발된다.
            - 그러므로 보통 배포 일정을 정하고, 그 기간 동안 개발된 모든 기능을 한번에 배포한다.
        - 마이크로서비스 단위로 확장할 수 있어 서비스 전체적으로 확장성이 좋다
            - 필요한 마이크로 서비스만 확장할 수 있다.
        - 사용자 반응에 민첩하게 대응할 수 있다.
            - 각각의 마이크로서비스는 독립되어 있으므로 서비스 특성에 맞는 프레임워크를 결정하여 시스템을 고도화하거나 제외하면 된다.
    - 단점
        - 개발하기 어려운 아키텍쳐다
            - 다른 시스템이 네트워크상에 분산되어 있기 때문이다.
                - 각 서비스마다 독립된 DB를 갖고있고, DB 트랜잭션을 사용할 수 없다.
                - 분산 트랜잭션을 사용할 수 있지만, 시스템 전체의 리소스를 많이 사용한다.
        - 운영하기 어려운 아키텍쳐다
            - 항공 예약 서비스 예제
                - 사용자 요청 인증 확인
                - 예약 정보로 항공 정보 마이크로서비스에 예약 시도
                - 항공 정보 마이크로 서비스는 예약 정보 유효성 검사후
                - RDB에 해당 좌석을 예약된 상태로 변경
                - 예약 마이크로 서비스에 예약 기록을 남긴다
            - 실제 현업에서는 이보다 더 복잡한 상황이 발생할 수 있다. 만약 위 절차중 에러가 발생한다면 디버깅 하는데 오랜 시간이 걸릴 것이다. 시스템 운영만으로 버거울 수 있다.
        - 설계하기 어려운 아키텍쳐다
            - 잘못된 방향으로 설계한다면 유지 보수하는데 더 어려울 수 있다.
            - 마이크로서비스의 관계가 명확하지 않다면 과도한 네트워크 통신이 발생
            - 하나의 마이크로서비스 영역이 너무 크면 또 하나의 모놀리식 아키텍쳐가 될 수 밖에 없다.
        - 여러가지 자동화된 시스템이 필요하다
            - MSA를 도입하기 위해서 CI/CD 시스템, 모니터링 시스템 등이 필요하고, 이러한 자동화 툴을 운영/ 유지보수 하는것도 쉬운일이 아니다.
        - 마이크로서비스를 운영하고 개발하는 개발자의 기술력이 좋아야 한다.
            - ‘피자 두판의 법칙’을 기억하라! 사람이 너무 많으면 생산성이 오히려 떨어질 수 있으니, 적절한 인원배치로 최고의 성과를 이끌려면 기술력이 좋아햐한다.

## 마이크로서비스 아키텍쳐 설계

잘 분리된 마이크로서비스를 설계하려면 어떻게 해야할까? MSA를 설계할때 정해진 법칙이나 왕도는 없다. 비즈니스 성격에 따라 각각 다르게 설계 한다.

### 1. 서비스 세분화 원칙

1. 비즈니스 기능
    1. 하나의 서비스가 여러 비즈니스 동작을 제공하면, 서비스 복잡도는 높아지고, 복잡도가 높아진 코드는 유지 보수가 어렵다.
2. 성능
    1. 한 마이크로 서비스 크기가 너무 커, 오버헤드가 발생한다면 나누는 것도 고려해보자.
3. 메시지 크기
    1. 성능과 연관이 있다. API 설계시 메시지 크기가 너무 크다면 직렬화/역직렬화시 문제가 발생할 수 있으므로 나누는 것을 고려해보자.
4. 트랜잭션
    1. 데이터 정합성을 유지하는 트랜잭션으로 서비스를 나누는 것도 좋다.

### 2. 도메인 주도 설계의 바운디드 컨텍스트

전체 서비스를 마이크로서비스로 분리하는 것은 어렵다. 얼마나 작게 나누어야할지 경계가 애매하기 때문이다. 이때 ‘도메인 모델이 다른 도메인과 확연히 구분되는 경계’에 맞추어 나누면 좋다. 이를 바운디드 컨텍스트라고 하는데, 바운디드 컨텍스트로 마이크로 서비스를 설계하면 중복될 확률이 줄어든다.

### 3. 단일 책임 원칙

우리가 무엇인가를 변경하려고 할때, 함께 변경되는 것이 있다면 그것들은 연관성이 있음을 의미한다.

연관성이 있다면 하나로 모으자. 그리고 서로 다른 이유로 변경되는 것들은 분리하자. 마이크로서비스도 마찬가지이다.

응집도는 Up, 결합도는 Down

### 4. 가벼운 통신 프로토콜

마이크로서비스 아키텍쳐 시스템을 아무리 이상적으로 잘 설계해도 마이크로서비스들이 서로 데이터를 참조하거나 수정/변경하는 상황이 발생한다. 이때 마이크로서비스들은 데이터를 통합하기 위해 네트워크를 사용하여 기능을 제공하는데, 이 때문에 여러 문제가 발생한다. 따라서 다음을 고려하여 설계하자.

→ 가벼운 네트워크 통신

→ 특정 기술이나 언어에 의존성이 없는 프로토콜

### 5. 외부 공개 인터페이스

버전 변경과 같은 방법을 이용해서 점진적으로 인터페이스를 변경.

### 6. 마이크로서비스마다 독립된 데이터 저장소

서비스 복잡성을 낮추기 위해 마이크로서비스로 분리했는데, 서비스의 데이터를 저장하는 데이터 저장소를 같이 사용하면 어떻게 될까? 각각의 마이크로서비스 독립성에 위배된다.

각각의 마이크로서비스는 처리하는 서비스 성격에 적합한 기술을 사용한다. 어떤 마이크로서비스는 데이터 정합성이 중요하고, 어던 마이크로서비스는 처리 속도와 처리량이 중요할 수 있다. 그러므로 데이터 정합성이 중요한 서비스는 이에 적합한 RDBMS 데이터를 사용하고, 트랜잭션의 격리 수준도 적절히 조절하면 된다. 데이터를 조회/노출하는 서비스로는 인메모리 데이터그리드를 고려할 수 있다.

## 12 요소 애플리케이션
클라우드 컴퓨팅 환경에 적합한 유연한 애플리케이션을 개발하는 방법론이 바로 12 요소 애플리케이션이다. 고려해야할 12가지 항목을 선정하고 각 항목마다 요구 사항들을 제안한다.

### 코드베이스: 버전 관리되는 하나의 코드베이스와 다양한 배포
코드 버전을 관리하는 툴은 개발자들이 코드를 생성하고 수정할 때마다 추적 가능하다. 
- 히스토리 관리에 유용
  - 예를들어 A개발자가 코드를 추가했다면, 태스크를 생성하고 버전 관리 시스템에 태스크 번호와 함께 코드를 커밋한다.
  - 이런 작업은 버그가 발생했을때 원인을 쉽게 파악할 수 있게 해준다
- 하나의 패키지 파일은 여러 환경에서 동작해야 한다.
  - Dev환경을 위한 코드베이스와 Production 환경을 위한 코드베이스를 구분하는 순간 소스 코드는 일관성을 잃고 운영 환경에 종속된다.
### 의존성: 명시적으로 선언할 수 있고 분리할 수 있는 의존성
개발할때는 JRE에서 제공하는 기본 라이브러리 외에 다른 라이브러리가 필요하다. 이때 애플리케이션은 특정 라이브러리에 의존성이 있다고 한다.

12요소 애플리케이션에서 이 의존성은 받느시 명시적으로 선언되어야 하고 분리되어 관리되어야 한다. 즉, 의존성 관리 도구와 의존성 선언 파일로 라이브러리 의존성을 관리해야 한다.

의존성 관리툴(mavn, gradle)을 사용하면 의존성이 있는 라이브러리들을 자동으로 개발 환경으로 내려받는다. 만약 이런 기능이 없다면 개발자는 다음 상황에 항상 개입해야한다.
- 개발 환경을 만들 때마다 개발자가 직접 라이브러리를 내려받아야 한다.
- 애플리케이션을 패키징 혹은 배포할 때마다 개발자는 라이브러리 목록을 확인하고 내려받아야 한다.

### 설정: 환경 변수를 이용한 설정
하나의 코드베이스는 여러환경에서 동작할 수 있다. 이때 배포된 환경마다 달라지는 값을 코드 내부에서 참조할 수 있다. 다음 항목들을 확인해보자.
- 애플리케이션마다 고유 이름이 필요하다
    - 환경 변수 APP_NAME을 통해 애플리케이션의 고유 이름을 설정할 수 있습니다. 이 이름은 로그, 모니터링, 또는 다른 서비스와의 통신에서 애플리케이션을 식별하는 데 사용될 수 있습니다.
~~~java
String app_name = System.getenv("APP_NAME");
if (app_name == null) {
    app_name = "DefaultAppName";
}
System.out.println("Application Name: " + app_name);
~~~
- 애플리케이션을 실행할 때 애플리케이션의 프로파일 이름이 필요하다
    - 환경 변수 APP_PROFILE을 통해 애플리케이션의 실행 프로파일을 설정할 수 있습니다. 이를 통해 개발, 테스트, 프로덕션 등의 다양한 환경에 맞는 설정을 적용할 수 있습니다.
~~~
String app_profile = System.getenv("APP_PROFILE");
if ("development".equals(app_profile)) {
    System.out.println("Running in development mode");
} else if ("production".equals(app_profile)) {
    System.out.println("Running in production mode");
}
~~~
- 스카우터나 핀포인트 같은 APM을 설정할 때는 설정파일과 에이전트 라이브러리 파일이 필요하다.
    - APM 설정을 위한 환경 변수도 도입할 수 있습니다. 예를 들어, APM_AGENT_PATH와 같은 환경 변수를 사용하여 APM 에이전트의 파일 경로를 지정할 수 있습니다. 이 정보는 애플리케이션을 시작할 때 APM 에이전트를 초기화하는 데 사용될 수 있습니다.
~~~java
String apm_agent_path = System.getenv("APM_AGENT_PATH");
if (apm_agent_path != null) {
    // APM 에이전트 초기화 로직
}
~~~
이렇게 환경 변수를 활용하면, 코드 변경 없이 애플리케이션을 다양한 환경에서 유연하게 실행할 수 있으며, 애플리케이션의 설정을 쉽게 관리할 수 있습니다

### 지원 서비스: 지원 서비스는 연결된 리소스로 처리
- 지원 서비스는 애플리케이션이 네트워크를 이용해서 사용하는 모든 서비스를 의미한다.
    - 예를들어 JDBC로 연결된 MySQL, MongoDB 같은 데이터 저장소나 결제 시스템 같은 네트워크로 연결되어 언제든지 애플리케이션과 연결하고 분리할 수 있어 리소스라고 한다.
- 같은 맥락에서 마이크로서비스 아키텍쳐도 마이크로서비스들을 연결하기 위해 REST-API나 RabbitMQ, Kafka 같은 메시지 브로커 시스템을 사용한다.
- 이를 쉽게 이용하기 위해 스프링은 일관된 방법으로 지원 서비스를 연결할 수 있는 방법을 제공한다.

### 빌드, 릴리스, 실행: 소스 빌드와 실행은 완전히 분리되어야 한다. 
- 빌드 단계
    - 의존성 있는 라이브러리들과 코드베이스를 조합하여 컴파일 한다.
- 릴리스 단계
    - 스프링 프로파일 혹은 메이븐 프로파일을 설정하여 resources에 위치한 설정 파일들을 조합한다.
    - 이때 스프링 부트에서 제공하는 플러그인은 컴파일된 코드와 설정파일을 조합하여 JAR파일을 생성한다
- 실행 단계
    - 앞서 생성된 실행 가능한 JAR 파일은 java 명령어를 이용해서 애플리케이션을 실행한다.
우리는 빌드된 소스 코드를 고칠 수 없고 실행된 애플리케이션은 빌드된 상태에서 동작한다. 소스 빌드와 실행이 완전히 분리되면 각 릴리스는 중간에 기능 수정이 있을 수 없다.
재현성: 빌드와 실행이 분리되면, 같은 빌드 결과물을 여러 환경에서 동일하게 실행할 수 있습니다. 이로 인해 문제가 발생했을 때 디버깅이 쉬워집니다.
안정성: 빌드된 소스 코드를 수정할 수 없기 때문에, 실행 중인 애플리케이션의 안정성이 높아집니다. 실수로 코드나 설정을 변경하는 일이 줄어듭니다.

### 프로세스: 애플리케이션은 하나 이상의 무상태 프로세스로 실행되어야 한다.
애플리케이션을 구성하는 프로세스들은 하나 혹은 그 이상의 프로세스들로 구성된다. 하지만 이들 프로세스들은 무상태이며 공유하는 것이 없어야 한다.

무상태성(statelessness)이 애플리케이션 로직과 상태 데이터를 분리하도록 강제하는 것은 아키텍쳐 상에서 중요한 원칙 중 하나입니다. 일반적으로 애플리케이션은 다양한 상태 정보를 다루게 되는데, 이 상태 정보를 애플리케이션 로직 내부에서 관리하게 되면 다음과 같은 문제가 발생할 수 있습니다

1. **확장성 문제**: 상태 정보를 애플리케이션 서버에서 관리하면, 해당 서버에 의존적인 상태가 형성됩니다. 이렇게 되면 부하 분산이나 확장성에 제약이 생깁니다.
  
2. **데이터 일관성 문제**: 여러 인스턴스에서 상태를 관리하게 되면, 각 인스턴스의 상태가 일관되게 유지되어야 하는 문제가 발생합니다.

3. **복잡성 증가**: 상태 정보를 내부에서 관리하게 되면, 상태 정보의 변경과 관련된 로직이 애플리케이션 코드 내에 포함되어야 하므로 코드가 복잡해질 수 있습니다.

무상태 애플리케이션에서는 이러한 문제를 피하기 위해 상태 정보를 외부 서비스에 위임합니다. 예를 들면:

- 사용자 세션 정보는 데이터베이스나 캐시에 저장될 수 있습니다.
- 메시지나 이벤트는 메시지 큐나 이벤트 스트림에 저장될 수 있습니다.
  
이렇게 함으로써, 애플리케이션 로직은 순수하게 비즈니스 로직에만 집중할 수 있고, 상태 정보는 외부 서비스가 효율적으로 관리하게 됩니다. 이 구조는 애플리케이션의 유지 보수성, 확장성, 그리고 안정성을 높이는 데 큰 도움을 줍니다.

### 포트 바인딩: 포트 바인딩을 통한 서비스 공개
애플리케이션을 외부 공격에서 보호하기 위해 클라우드 환경에서 모든 애플리케이션은 특정 포트가 바인딩되도록 설계한다.

### 동시성: 프로세스들을 통한 수평 확장
자바 프로그래밍에서는 동시성을 다루는데 스레드를 이용한다. 웹 애플리케이션도 마찬가지로 제티나 톰캣 같은 WAS가 내부적으로 스레드를 관리해서 자연스럽게 멀티스레드 프로그램이 동작한다. 클라우드 환경에서는 스레드 프로그래밍 외에도 프로세스를 이용해서 동시성을 관리한다. 

### 폐기 가능: 프로세스는 빠르게 시작해야 하고 안정적으로 종료해야한다.



### Dev 환경과 Production 환경 일치

### 로그: 로그는 이벤트 스트림으로 다룬다

### admin 프로세스: 시스템 유지 보수를 위한 일회성 프로세스

## 용어 정리

1. **REST API (Representational State Transfer API)**
    - 용도: 웹 서비스에서 데이터와 기능을 제공하기 위한 인터페이스. 일반적으로 HTTP/HTTPS 프로토콜을 사용하여 클라이언트와 서버 간의 상호작용을 정의합니다. RESTful 아키텍처를 따르는 API는 일반적으로 CRUD 연산 (생성, 읽기, 수정, 삭제)을 기반으로 합니다.
2. **gRPC**
    - 용도: Google에서 개발한 오픈 소스 원격 프로시저 호출 (RPC) 시스템입니다. 프로토콜 버퍼(Protobuf)를 기반으로 메시지 및 서비스 정의를 사용합니다. gRPC는 낮은 지연 시간, 높은 성능, 다양한 프로그래밍 언어 지원을 목표로 합니다.
3. **Thrift**
    - 용도: Apache Thrift는 Facebook에서 시작한 RPC 프레임워크입니다. 다양한 프로그래밍 언어에서 서버와 클라이언트 간의 통신을 위한 인터페이스를 생성하도록 설계되었습니다.
4. **Avro**
    - 용도: Apache Avro는 데이터 직렬화 라이브러리입니다. 주로 빅 데이터와 Hadoop 응용 프로그램에서 사용됩니다. 스키마를 포함한 데이터 직렬화 방식을 사용하여 데이터를 효과적으로 저장 및 전송합니다.
5. **Protobuffer (또는 Protocol Buffers)**
    - 용도: Google에서 개발한 직렬화 포맷입니다. 데이터 구조를 **`.proto`** 파일에 정의하고, 그 구조를 기반으로 코드를 생성하여 데이터를 효과적으로 직렬화 및 역직렬화 할 수 있습니다. gRPC와 함께 자주 사용됩니다.
6. **AMQP (Advanced Message Queuing Protocol)**
    - 용도: 메시지 지향 미들웨어에 사용되는 어플리케이션 계층의 프로토콜입니다. 메시지 전달, 큐 관리, 라우팅 등의 기능을 명세화합니다.
7. **RabbitMQ**
    - 용도: 메시지 브로커로서 AMQP 프로토콜을 구현합니다. 시스템 간에 메시지를 안전하게 전달하고 저장하는 중간자 역할을 합니다. 분산 시스템에서 메시지 기반의 통신을 지원하게 해줍니다.
8. **Kafka**
    - 용도: Apache Kafka는 분산 스트림 처리 플랫폼입니다. 대량의 실시간 데이터 스트림을 효과적으로 처리, 저장, 전송할 수 있도록 설계되었습니다. 빅 데이터와 실시간 분석 응용 프로그램에 널리 사용됩니다.

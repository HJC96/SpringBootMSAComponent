# 스프링 부트로 개발하는 MSA 컴포넌트

# 마이크로서비스 아키텍쳐 소개

---

## 모놀리식 아키텍쳐

- 서비스 기능을 하나의 API 컴포넌트에서 처리하는 구조
- 장점
    - 하나의 WAS에서 모든 기능을 처리
        - HTML, JS/CSS, Servlet, 이미지
    - 하나의 DB를 이용 → 구조가 간단하다
    - 시스템 개발과 운영이 자유롭다.
    - 네트워크 지연이나 데이터 유실을 걱정할 필요가 없다.
        - MSA는 마이크로 서비스 사이에 네트워크를 통해 전송되기에 데이터 유실에 대한 고려를 해야한다.
            - 또한, 통신에 사용되는 네트워크 프로토콜은 가벼워야 한다.(JSON 같은 형식의 메시지)
- 단점
    - 하나의 애플리케이션에서 모든 것을 수행하다보니 서비스 기능이 많아지면, 스파게티 코드가 될 수 있다.
    - 결국 서비스가 커지면 개발 속도나 생산성이 낮아진다.

## MSA로 전환을 고려해 볼 기준

1. 클라이언트 요청이 점점 많아지는데 로드 밸런서로 확장해도 한계가 있을때
2. 데이터베이스 성능을 높여도 더 이상 개선의 여지가 없을 때
3. 기능 확장 요구가 많짐나 현재 시스템 구조로 불가능할 때
4. 소스 코드가 너무 복잡해서 리팩터링이 필요할때
5. 기능 중 하나라도 변경되면 전체 QA를 해야할 때
6. 기능을 수정하면 다른 기능에 연쇄적으로 버그가 발생할 때
7. 개발자는 늘었는데, 개발 속도는 이전같지 않을 때

## 분산 처리 시스템

- 서비스 기능을 분리하여 두 개 이상의 API 컴포넌트에서 처리하는 구조
    - 마이크로 서비스 아키텍쳐는 분산 시스템 아키텍쳐 중 하나이다.
    - 구현이 어렵고, 여러 시스템이 유기적으로 얽혀 있어 운영이 쉽지 않다.

## 마이크로서비스 아키텍쳐

- 마이크로 서비스라는 작은 단위의 컴포넌트로 구성
    - 장점
        - 각각의 컴포넌트는 독립된 시스템 형태로 개발하고 운영
            - 느슨한 결합 → 독립된 데이터 저장소가 필요하다.
            - 서비스 변화에 자유롭다, 독립성과 민첩성을 확보
        - 대용량 데이터를 저장하고 처리하는데 자유롭다
        - 시스템 장애에 견고하다
            - 느슨하게 결합되어 있기에 서로 간에 미치는 영향이 적다.
        - 서비스 배포 주기가 빠르다
            - 모놀리식 아키텍쳐는 모든 기능이 하나의 코드베이스에서 개발된다.
            - 그러므로 보통 배포 일정을 정하고, 그 기간 동안 개발된 모든 기능을 한번에 배포한다.
        - 마이크로서비스 단위로 확장할 수 있어 서비스 전체적으로 확장성이 좋다
            - 필요한 마이크로 서비스만 확장할 수 있다.
        - 사용자 반응에 민첩하게 대응할 수 있다.
            - 각각의 마이크로서비스는 독립되어 있으므로 서비스 특성에 맞는 프레임워크를 결정하여 시스템을 고도화하거나 제외하면 된다.
    - 단점
        - 개발하기 어려운 아키텍쳐다
            - 다른 시스템이 네트워크상에 분산되어 있기 때문이다.
                - 각 서비스마다 독립된 DB를 갖고있고, DB 트랜잭션을 사용할 수 없다.
                - 분산 트랜잭션을 사용할 수 있지만, 시스템 전체의 리소스를 많이 사용한다.
        - 운영하기 어려운 아키텍쳐다
            - 항공 예약 서비스 예제
                - 사용자 요청 인증 확인
                - 예약 정보로 항공 정보 마이크로서비스에 예약 시도
                - 항공 정보 마이크로 서비스는 예약 정보 유효성 검사후
                - RDB에 해당 좌석을 예약된 상태로 변경
                - 예약 마이크로 서비스에 예약 기록을 남긴다
            - 실제 현업에서는 이보다 더 복잡한 상황이 발생할 수 있다. 만약 위 절차중 에러가 발생한다면 디버깅 하는데 오랜 시간이 걸릴 것이다. 시스템 운영만으로 버거울 수 있다.
        - 설계하기 어려운 아키텍쳐다
            - 잘못된 방향으로 설계한다면 유지 보수하는데 더 어려울 수 있다.
            - 마이크로서비스의 관계가 명확하지 않다면 과도한 네트워크 통신이 발생
            - 하나의 마이크로서비스 영역이 너무 크면 또 하나의 모놀리식 아키텍쳐가 될 수 밖에 없다.
        - 여러가지 자동화된 시스템이 필요하다
            - MSA를 도입하기 위해서 CI/CD 시스템, 모니터링 시스템 등이 필요하고, 이러한 자동화 툴을 운영/ 유지보수 하는것도 쉬운일이 아니다.
        - 마이크로서비스를 운영하고 개발하는 개발자의 기술력이 좋아야 한다.
            - ‘피자 두판의 법칙’을 기억하라! 사람이 너무 많으면 생산성이 오히려 떨어질 수 있으니, 적절한 인원배치로 최고의 성과를 이끌려면 기술력이 좋아햐한다.

## 마이크로서비스 아키텍쳐 설계

잘 분리된 마이크로서비스를 설계하려면 어떻게 해야할까? MSA를 설계할때 정해진 법칙이나 왕도는 없다. 비즈니스 성격에 따라 각각 다르게 설계 한다.

### 1. 서비스 세분화 원칙

1. 비즈니스 기능
    1. 하나의 서비스가 여러 비즈니스 동작을 제공하면, 서비스 복잡도는 높아지고, 복잡도가 높아진 코드는 유지 보수가 어렵다.
2. 성능
    1. 한 마이크로 서비스 크기가 너무 커, 오버헤드가 발생한다면 나누는 것도 고려해보자.
3. 메시지 크기
    1. 성능과 연관이 있다. API 설계시 메시지 크기가 너무 크다면 직렬화/역직렬화시 문제가 발생할 수 있으므로 나누는 것을 고려해보자.
4. 트랜잭션
    1. 데이터 정합성을 유지하는 트랜잭션으로 서비스를 나누는 것도 좋다.

### 2. 도메인 주도 설계의 바운디드 컨텍스트

전체 서비스를 마이크로서비스로 분리하는 것은 어렵다. 얼마나 작게 나누어야할지 경계가 애매하기 때문이다. 이때 ‘도메인 모델이 다른 도메인과 확연히 구분되는 경계’에 맞추어 나누면 좋다. 이를 바운디드 컨텍스트라고 하는데, 바운디드 컨텍스트로 마이크로 서비스를 설계하면 중복될 확률이 줄어든다.

### 3. 단일 책임 원칙

우리가 무엇인가를 변경하려고 할때, 함께 변경되는 것이 있다면 그것들은 연관성이 있음을 의미한다.

연관성이 있다면 하나로 모으자. 그리고 서로 다른 이유로 변경되는 것들은 분리하자. 마이크로서비스도 마찬가지이다.

응집도는 Up, 결합도는 Down

### 4. 가벼운 통신 프로토콜

마이크로서비스 아키텍쳐 시스템을 아무리 이상적으로 잘 설계해도 마이크로서비스들이 서로 데이터를 참조하거나 수정/변경하는 상황이 발생한다. 이때 마이크로서비스들은 데이터를 통합하기 위해 네트워크를 사용하여 기능을 제공하는데, 이 때문에 여러 문제가 발생한다. 따라서 다음을 고려하여 설계하자.

→ 가벼운 네트워크 통신

→ 특정 기술이나 언어에 의존성이 없는 프로토콜

### 5. 외부 공개 인터페이스

버전 변경과 같은 방법을 이용해서 점진적으로 인터페이스를 변경.

### 6. 마이크로서비스마다 독립된 데이터 저장소

서비스 복잡성을 낮추기 위해 마이크로서비스로 분리했는데, 서비스의 데이터를 저장하는 데이터 저장소를 같이 사용하면 어떻게 될까? 각각의 마이크로서비스 독립성에 위배된다.

각각의 마이크로서비스는 처리하는 서비스 성격에 적합한 기술을 사용한다. 어떤 마이크로서비스는 데이터 정합성이 중요하고, 어던 마이크로서비스는 처리 속도와 처리량이 중요할 수 있다. 그러므로 데이터 정합성이 중요한 서비스는 이에 적합한 RDBMS 데이터를 사용하고, 트랜잭션의 격리 수준도 적절히 조절하면 된다. 데이터를 조회/노출하는 서비스로는 인메모리 데이터그리드를 고려할 수 있다.

## 12 요소 애플리케이션
클라우드 컴퓨팅 환경에 적합한 유연한 애플리케이션을 개발하는 방법론이 바로 12 요소 애플리케이션이다. 고려해야할 12가지 항목을 선정하고 각 항목마다 요구 사항들을 제안한다.

### 코드베이스: 버전 관리되는 하나의 코드베이스와 다양한 배포
코드 버전을 관리하는 툴은 개발자들이 코드를 생성하고 수정할 때마다 추적 가능하다. 
- 히스토리 관리에 유용
  - 예를들어 A개발자가 코드를 추가했다면, 태스크를 생성하고 버전 관리 시스템에 태스크 번호와 함께 코드를 커밋한다.
  - 이런 작업은 버그가 발생했을때 원인을 쉽게 파악할 수 있게 해준다
- 하나의 패키지 파일은 여러 환경에서 동작해야 한다.
  - Dev환경을 위한 코드베이스와 Production 환경을 위한 코드베이스를 구분하는 순간 소스 코드는 일관성을 잃고 운영 환경에 종속된다.
### 의존성: 명시적으로 선언할 수 있고 분리할 수 있는 의존성
개발할때는 JRE에서 제공하는 기본 라이브러리 외에 다른 라이브러리가 필요하다. 이때 애플리케이션은 특정 라이브러리에 의존성이 있다고 한다.

12요소 애플리케이션에서 이 의존성은 받느시 명시적으로 선언되어야 하고 분리되어 관리되어야 한다. 즉, 의존성 관리 도구와 의존성 선언 파일로 라이브러리 의존성을 관리해야 한다.

의존성 관리툴(mavn, gradle)을 사용하면 의존성이 있는 라이브러리들을 자동으로 개발 환경으로 내려받는다. 만약 이런 기능이 없다면 개발자는 다음 상황에 항상 개입해야한다.
- 개발 환경을 만들 때마다 개발자가 직접 라이브러리를 내려받아야 한다.
- 애플리케이션을 패키징 혹은 배포할 때마다 개발자는 라이브러리 목록을 확인하고 내려받아야 한다.

### 설정: 환경 변수를 이용한 설정




## 용어 정리

1. **REST API (Representational State Transfer API)**
    - 용도: 웹 서비스에서 데이터와 기능을 제공하기 위한 인터페이스. 일반적으로 HTTP/HTTPS 프로토콜을 사용하여 클라이언트와 서버 간의 상호작용을 정의합니다. RESTful 아키텍처를 따르는 API는 일반적으로 CRUD 연산 (생성, 읽기, 수정, 삭제)을 기반으로 합니다.
2. **gRPC**
    - 용도: Google에서 개발한 오픈 소스 원격 프로시저 호출 (RPC) 시스템입니다. 프로토콜 버퍼(Protobuf)를 기반으로 메시지 및 서비스 정의를 사용합니다. gRPC는 낮은 지연 시간, 높은 성능, 다양한 프로그래밍 언어 지원을 목표로 합니다.
3. **Thrift**
    - 용도: Apache Thrift는 Facebook에서 시작한 RPC 프레임워크입니다. 다양한 프로그래밍 언어에서 서버와 클라이언트 간의 통신을 위한 인터페이스를 생성하도록 설계되었습니다.
4. **Avro**
    - 용도: Apache Avro는 데이터 직렬화 라이브러리입니다. 주로 빅 데이터와 Hadoop 응용 프로그램에서 사용됩니다. 스키마를 포함한 데이터 직렬화 방식을 사용하여 데이터를 효과적으로 저장 및 전송합니다.
5. **Protobuffer (또는 Protocol Buffers)**
    - 용도: Google에서 개발한 직렬화 포맷입니다. 데이터 구조를 **`.proto`** 파일에 정의하고, 그 구조를 기반으로 코드를 생성하여 데이터를 효과적으로 직렬화 및 역직렬화 할 수 있습니다. gRPC와 함께 자주 사용됩니다.
6. **AMQP (Advanced Message Queuing Protocol)**
    - 용도: 메시지 지향 미들웨어에 사용되는 어플리케이션 계층의 프로토콜입니다. 메시지 전달, 큐 관리, 라우팅 등의 기능을 명세화합니다.
7. **RabbitMQ**
    - 용도: 메시지 브로커로서 AMQP 프로토콜을 구현합니다. 시스템 간에 메시지를 안전하게 전달하고 저장하는 중간자 역할을 합니다. 분산 시스템에서 메시지 기반의 통신을 지원하게 해줍니다.
8. **Kafka**
    - 용도: Apache Kafka는 분산 스트림 처리 플랫폼입니다. 대량의 실시간 데이터 스트림을 효과적으로 처리, 저장, 전송할 수 있도록 설계되었습니다. 빅 데이터와 실시간 분석 응용 프로그램에 널리 사용됩니다.
